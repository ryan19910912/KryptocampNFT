import {
  require_src,
  require_src2,
  require_src3
} from "./chunk-4C3L7FD7.js";
import {
  assertWindowEthereum
} from "./chunk-FETDTUNB.js";
import {
  WagmiAdapter
} from "./chunk-DCR354S2.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-4MZS4CQC.js";
import {
  Ethereum,
  defaultChains
} from "./chunk-PJ36WQVC.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-GI3CIENS.js";
import {
  _defineProperty,
  eventemitter3_default
} from "./chunk-44DZRTPR.js";
import {
  Contract,
  ethers_exports,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-GTQDYEZ2.js";
import {
  lib_exports19 as lib_exports
} from "./chunk-AVG4MCCG.js";
import {
  init_shim,
  require_buffer
} from "./chunk-ZGMFR26H.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/dist/base-901ad5ac.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_shim();
init_lib();
function chainIdToThirdwebRpc(chainId) {
  return `https://${chainId}.rpc.thirdweb.com`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
    _defineProperty(this, "signerPromise", void 0);
  }
  async getAddress() {
    const signer = await this.getCachedSigner();
    return signer.getAddress();
  }
  async getChainId() {
    const signer = await this.getCachedSigner();
    return signer.getChainId();
  }
  async signMessage(message) {
    const signer = await this.getCachedSigner();
    return await signer.signMessage(message);
  }
  async verifySignature(message, signature, address, chainId) {
    const messageHash = utils_exports.hashMessage(message);
    const messageHashBytes = utils_exports.arrayify(messageHash);
    const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
    if (recoveredAddress === address) {
      return true;
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
  async getCachedSigner() {
    if (this.signerPromise) {
      return this.signerPromise;
    }
    this.signerPromise = this.getSigner().catch(() => {
      this.signerPromise = void 0;
      throw new Error("Unable to get a signer!");
    });
    return this.signerPromise;
  }
};

// node_modules/@thirdweb-dev/wallets/dist/base-901ad5ac.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    _defineProperty(this, "name", void 0);
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var _connect = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _connect);
    _defineProperty(this, "walletId", void 0);
    _defineProperty(this, "walletStorage", void 0);
    _defineProperty(this, "chains", void 0);
    _defineProperty(this, "dappMetadata", void 0);
    _defineProperty(this, "options", void 0);
    this.walletId = walletId;
    this.options = options;
    this.chains = (options == null ? void 0 : options.chains) || defaultChains;
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  async connect(connectOptions) {
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains;
    const connector = await this.getConnector();
    connector.updateChains(chains);
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address2 = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address: address2,
      chainId: await this.getChainId()
    });
    return address2;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  const address = await connector.connect(connectOptions);
  return address;
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data) => {
    var _a;
    this.emit("connect", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data) => {
    var _a;
    this.emit("change", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data) => {
    this.emit("message", data);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}
_defineProperty(AbstractClientWallet, "meta", void 0);

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_lib();
var PaperWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    super(PaperWallet.id, {
      ...options
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "clientId", void 0);
    _defineProperty(this, "chain", void 0);
    this.clientId = options.clientId;
    this.chain = options.chain;
    this.chains = options.chains;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-2K6VAMEA.js");
      this.connector = new PaperWalletConnector({
        clientId: this.clientId,
        chain: this.chain,
        chains: this.chains
      });
    }
    return this.connector;
  }
  async updateChains(chains) {
    this.chains = chains;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
};
_defineProperty(PaperWallet, "id", "PaperWallet");
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect = class extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnect.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "projectId", void 0);
    _defineProperty(this, "qrcode", void 0);
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider, data.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("open_wallet", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("open_wallet");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-KOUAZ7DK.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect, "id", "walletConnect");
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib();
var import_safe_ethers_adapters = __toESM(require_src());
var import_safe_core_sdk = __toESM(require_src2());
var import_safe_ethers_lib = __toESM(require_src3());
var SafeWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(SafeWallet.id, {
      ...options
    });
    _defineProperty(this, "connector", void 0);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-LDU6M4J3.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  async updateChains(chains) {
  }
  async connect(connectOptions) {
    return await super.connect({
      ...connectOptions,
      saveParams: false
    });
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", "Safe");

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(CoinbaseWallet.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "coinbaseConnector", void 0);
    _defineProperty(this, "headlessMode", void 0);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-42TN4B4Y.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.dappMetadata.isDarkMode,
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet"
});
_defineProperty(CoinbaseWallet, "id", "coinbaseWallet");

// node_modules/@thirdweb-dev/wallets/evm/wallets/device-wallet/dist/thirdweb-dev-wallets-evm-wallets-device-wallet.browser.esm.js
init_shim();
init_lib();
var STORAGE_KEY_DATA = "data";
var STORAGE_KEY_ADDR = "address";
var _walletImpl = /* @__PURE__ */ new WeakMap();
var DeviceBrowserWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Device Wallet";
  }
  constructor(options) {
    super(DeviceBrowserWallet.id, {
      ...options
    });
    _defineProperty(this, "connector", void 0);
    _classPrivateFieldInitSpec(this, _walletImpl, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "options", void 0);
    this.options = options;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        DeviceWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-device-wallet.browser.esm-74HGZWVC.js");
      let wallet;
      switch (this.options.storageType) {
        case "asyncStore":
          wallet = await DeviceWalletImpl.fromAsyncStorage(this.options.storage || createAsyncLocalStorage("deviceWallet"));
          break;
        case "credentialStore":
          wallet = await DeviceWalletImpl.fromCredentialStore();
          break;
        default:
          wallet = await DeviceWalletImpl.fromAsyncStorage(this.options.storage || createAsyncLocalStorage("deviceWallet"));
      }
      this.connector = new DeviceWalletConnector({
        chain: this.options.chain || Ethereum,
        wallet,
        chains: this.options.chains || defaultChains
      });
      _classPrivateFieldSet(this, _walletImpl, wallet);
    }
    return this.connector;
  }
  getWalletData() {
    if (!_classPrivateFieldGet(this, _walletImpl)) {
      throw new Error("Wallet not initialized");
    }
    return _classPrivateFieldGet(this, _walletImpl).getWalletData();
  }
  static getAddressStorageKey() {
    return STORAGE_KEY_ADDR;
  }
  static getDataStorageKey() {
    return STORAGE_KEY_DATA;
  }
};
_defineProperty(DeviceBrowserWallet, "id", "deviceWallet");
_defineProperty(DeviceBrowserWallet, "meta", {
  name: "Device Wallet",
  iconURL: "ipfs://QmcNddbYBuQKiBFnPcxYegjrX6S6z9K1vBNzbBBUJMn2ox/device-wallet.svg"
});
var _wallet = /* @__PURE__ */ new WeakMap();
var DeviceWalletImpl = class extends AbstractWallet {
  static async fromAsyncStorage(storage) {
    return new DeviceWalletImpl({
      storage: new AsyncWalletStorage(storage)
    });
  }
  static async fromCredentialStore() {
    return new DeviceWalletImpl({
      storage: new CredentialsStorage(navigator.credentials)
    });
  }
  constructor(options) {
    super();
    _defineProperty(this, "options", void 0);
    _classPrivateFieldInitSpec(this, _wallet, {
      writable: true,
      value: void 0
    });
    this.options = options;
  }
  async getSigner(provider) {
    if (!_classPrivateFieldGet(this, _wallet)) {
      throw new Error("Wallet not initialized");
    }
    let wallet = _classPrivateFieldGet(this, _wallet);
    if (provider) {
      wallet = wallet.connect(provider);
    }
    return wallet;
  }
  async getSavedWalletAddress() {
    const data = await this.options.storage.getWalletData();
    if (!data) {
      return null;
    }
    return data.address;
  }
  async generateNewWallet() {
    const wallet = ethers_exports.Wallet.createRandom();
    _classPrivateFieldSet(this, _wallet, wallet);
    return wallet.address;
  }
  async loadSavedWallet(password) {
    const data = await this.options.storage.getWalletData();
    if (!data) {
      throw new Error("No saved wallet");
    }
    const wallet = await ethers_exports.Wallet.fromEncryptedJson(data.encryptedData, password);
    _classPrivateFieldSet(this, _wallet, wallet);
    return wallet.address;
  }
  async save(password) {
    const wallet = await this.getSigner();
    const options = {
      scrypt: {
        N: 1 << 32
      }
    };
    const encryptedData = await wallet.encrypt(password, options);
    await this.options.storage.storeWalletData({
      address: wallet.address,
      encryptedData
    });
  }
  async export(password) {
    const wallet = await this.getSigner();
    return wallet.encrypt(password);
  }
  getWalletData() {
    return this.options.storage.getWalletData();
  }
};
var AsyncWalletStorage = class {
  constructor(storage) {
    _defineProperty(this, "storage", void 0);
    this.storage = storage;
  }
  async getWalletData() {
    const [address, encryptedData] = await Promise.all([this.storage.getItem(STORAGE_KEY_ADDR), this.storage.getItem(STORAGE_KEY_DATA)]);
    if (!address || !encryptedData) {
      return null;
    }
    return {
      address,
      encryptedData
    };
  }
  async storeWalletData(data) {
    await Promise.all([this.storage.setItem(STORAGE_KEY_ADDR, data.address), this.storage.setItem(STORAGE_KEY_DATA, data.encryptedData)]);
  }
};
var CredentialsStorage = class {
  constructor(container) {
    _defineProperty(this, "container", void 0);
    this.container = container;
  }
  async getWalletData() {
    const credential = await this.container.get({
      password: true,
      unmediated: true
    });
    if (credential && "password" in credential) {
      return {
        address: credential.id,
        encryptedData: credential.password
      };
    }
    return null;
  }
  async storeWalletData(data) {
    if ("PasswordCredential" in window) {
      let credentialData = {
        id: data.address,
        password: data.encryptedData
      };
      const credential = await this.container.create({
        password: credentialData
      });
      if (!credential) {
        throw new Error("Credential not created");
      }
      await this.container.store(credential);
    } else {
      throw new Error("PasswordCredential not supported");
    }
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib();
var InjectedWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(InjectedWallet.id, options);
    _defineProperty(this, "connector", void 0);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-MB5OQIUQ.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib();
var MetaMaskWallet = class extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    var _a;
    super(MetaMaskWallet.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "walletConnectConnector", void 0);
    _defineProperty(this, "isInjected", void 0);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isMetaMask);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-JMJ6PRB7.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectV1Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-G4TWEPEY.js");
        const walletConnectConnector = new WalletConnectV1Connector({
          chains: this.chains,
          storage: this.walletStorage,
          options: {
            clientMeta: {
              name: this.dappMetadata.name,
              description: this.dappMetadata.description || "",
              url: this.dappMetadata.url,
              icons: [this.dappMetadata.logoUrl || ""]
            },
            qrcode: (_a = this.options) == null ? void 0 : _a.qrcode
          }
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.connector.on("display_uri", (error, payload) => {
      options.onQrCodeUri(payload.params[0]);
    });
    await wcProvider.enable();
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg"
});
_defineProperty(MetaMaskWallet, "id", "metamask");

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib();
var _walletConnectConnector2 = /* @__PURE__ */ new WeakMap();
var _provider2 = /* @__PURE__ */ new WeakMap();
var _onConnect2 = /* @__PURE__ */ new WeakMap();
var _onDisconnect2 = /* @__PURE__ */ new WeakMap();
var _onChange2 = /* @__PURE__ */ new WeakMap();
var _onMessage2 = /* @__PURE__ */ new WeakMap();
var _setupListeners3 = /* @__PURE__ */ new WeakSet();
var _removeListeners3 = /* @__PURE__ */ new WeakSet();
var WalletConnectV1 = class extends AbstractClientWallet {
  get walletName() {
    var _a;
    return ((_a = _classPrivateFieldGet(this, _walletConnectConnector2)) == null ? void 0 : _a.walletName) || "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnectV1.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners3);
    _classPrivateMethodInitSpec(this, _setupListeners3);
    _classPrivateFieldInitSpec(this, _walletConnectConnector2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider2, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "qrcode", void 0);
    _classPrivateFieldInitSpec(this, _onConnect2, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider2, data.provider);
        if (!_classPrivateFieldGet(this, _provider2)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect2, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners3, _removeListeners22).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange2, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage2, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "request":
          case "add_chain":
          case "switch_chain":
            this.emit("open_wallet");
            break;
          case "display_uri":
            this.emit("open_wallet", payload.data);
            break;
        }
      }
    });
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        WalletConnectV1Connector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-G4TWEPEY.js");
      _classPrivateFieldSet(this, _walletConnectConnector2, new WalletConnectV1Connector({
        chains: this.chains,
        storage: this.walletStorage,
        options: {
          qrcode: this.qrcode,
          clientMeta: {
            description: this.dappMetadata.description || "",
            url: this.dappMetadata.url,
            icons: [this.dappMetadata.logoUrl || ""],
            name: this.dappMetadata.name
          }
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector2));
      _classPrivateFieldSet(this, _provider2, await _classPrivateFieldGet(this, _walletConnectConnector2).getProvider());
      _classPrivateMethodGet(this, _setupListeners3, _setupListeners22).call(this);
    }
    return this.connector;
  }
};
function _setupListeners22() {
  if (!_classPrivateFieldGet(this, _walletConnectConnector2)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector2).on("connect", _classPrivateFieldGet(this, _onConnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("disconnect", _classPrivateFieldGet(this, _onDisconnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("change", _classPrivateFieldGet(this, _onChange2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("message", _classPrivateFieldGet(this, _onMessage2));
}
function _removeListeners22() {
  if (!_classPrivateFieldGet(this, _walletConnectConnector2)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("connect", _classPrivateFieldGet(this, _onConnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("change", _classPrivateFieldGet(this, _onChange2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("message", _classPrivateFieldGet(this, _onMessage2));
}
_defineProperty(WalletConnectV1, "id", "walletConnectV1");
_defineProperty(WalletConnectV1, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib();
var import_buffer2 = __toESM(require_buffer());
var import_safe_ethers_adapters2 = __toESM(require_src());
var import_safe_core_sdk2 = __toESM(require_src2());
var import_safe_ethers_lib2 = __toESM(require_src3());

export {
  createAsyncLocalStorage,
  PaperWallet,
  CoinbaseWallet,
  MetaMaskWallet,
  WalletConnect,
  WalletConnectV1,
  SafeWallet
};
//# sourceMappingURL=chunk-E4Q5ZKW5.js.map
